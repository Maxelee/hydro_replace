"""
Ray-Tracing Engine
==================

Interface to the Lux ray-tracing code.
"""

from __future__ import annotations

import logging
import os
import subprocess
import tempfile
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

import numpy as np

logger = logging.getLogger(__name__)


@dataclass
class RayTraceConfig:
    """
    Configuration for ray-tracing with Lux.

    Attributes
    ----------
    input_path : str
        Path to input particle data.
    output_path : str
        Path for output convergence maps.
    lp_grid : int
        Light-cone pixelization grid size.
    rt_grid : int
        Ray-tracing grid size.
    fov : float
        Field of view in degrees.
    n_source_planes : int
        Number of source redshift planes.
    source_redshifts : list
        Source plane redshifts.
    cosmology : dict
        Cosmological parameters.
    box_size : float
        Simulation box size in Mpc/h.
    n_copies : int
        Number of box copies for tiling.
    """
    
    input_path: str = ""
    output_path: str = ""
    lp_grid: int = 4096
    rt_grid: int = 1024
    fov: float = 5.0
    n_source_planes: int = 1
    source_redshifts: List[float] = field(default_factory=lambda: [1.0])
    cosmology: Dict[str, float] = field(default_factory=lambda: {
        'omega_m': 0.3089,
        'omega_l': 0.6911,
        'omega_b': 0.0486,
        'h': 0.6774,
        'sigma8': 0.8159,
        'ns': 0.9667,
    })
    box_size: float = 205.0
    n_copies: int = 3
    random_seed: int = 12345
    
    def to_dict(self) -> Dict:
        """Convert to dictionary."""
        return {
            'input_path': self.input_path,
            'output_path': self.output_path,
            'lp_grid': self.lp_grid,
            'rt_grid': self.rt_grid,
            'fov': self.fov,
            'n_source_planes': self.n_source_planes,
            'source_redshifts': self.source_redshifts,
            'cosmology': self.cosmology,
            'box_size': self.box_size,
            'n_copies': self.n_copies,
            'random_seed': self.random_seed,
        }
    
    @classmethod
    def from_yaml(cls, config_path: Union[str, Path]) -> 'RayTraceConfig':
        """Load configuration from YAML file."""
        import yaml
        with open(config_path, 'r') as f:
            config = yaml.safe_load(f)
        return cls(**config.get('raytrace', config))


def generate_lux_config(
    config: RayTraceConfig,
    output_file: Union[str, Path],
) -> Path:
    """
    Generate a Lux configuration file.

    Parameters
    ----------
    config : RayTraceConfig
        Ray-tracing configuration.
    output_file : str or Path
        Output path for config file.

    Returns
    -------
    config_path : Path
        Path to generated config file.

    Examples
    --------
    >>> config = RayTraceConfig(
    ...     input_path='/data/particles.h5',
    ...     output_path='/output/kappa.fits',
    ... )
    >>> generate_lux_config(config, 'lux.ini')
    """
    output_file = Path(output_file)
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    cosmo = config.cosmology
    
    # Format source redshifts as comma-separated string
    z_sources = ','.join(str(z) for z in config.source_redshifts)
    
    content = f"""# Lux ray-tracing configuration
# Generated by hydro_replace pipeline

[General]
input_file = {config.input_path}
output_prefix = {config.output_path}
random_seed = {config.random_seed}

[Cosmology]
omega_m = {cosmo.get('omega_m', 0.3089)}
omega_l = {cosmo.get('omega_l', 0.6911)}
omega_b = {cosmo.get('omega_b', 0.0486)}
h = {cosmo.get('h', 0.6774)}
sigma8 = {cosmo.get('sigma8', 0.8159)}
ns = {cosmo.get('ns', 0.9667)}

[Simulation]
box_size = {config.box_size}
n_copies = {config.n_copies}

[LightCone]
lp_grid = {config.lp_grid}
fov = {config.fov}

[RayTracing]
rt_grid = {config.rt_grid}
n_source_planes = {config.n_source_planes}
source_redshifts = {z_sources}
"""
    
    with open(output_file, 'w') as f:
        f.write(content)
    
    logger.info(f"Generated Lux config: {output_file}")
    return output_file


class LuxInterface:
    """
    Interface to the Lux ray-tracing code.

    Parameters
    ----------
    lux_executable : str or Path
        Path to Lux executable.
    work_dir : str or Path, optional
        Working directory for temporary files.
    """
    
    def __init__(
        self,
        lux_executable: Union[str, Path] = "lux",
        work_dir: Optional[Union[str, Path]] = None,
    ):
        self.lux_executable = Path(lux_executable)
        self.work_dir = Path(work_dir) if work_dir else Path.cwd()
        
        # Check if executable exists
        if not self.lux_executable.exists():
            # Try to find in PATH
            import shutil
            found = shutil.which(str(lux_executable))
            if found:
                self.lux_executable = Path(found)
            else:
                logger.warning(f"Lux executable not found: {lux_executable}")
    
    def run(
        self,
        config: RayTraceConfig,
        mpi_ranks: int = 1,
        verbose: bool = True,
    ) -> Tuple[bool, str]:
        """
        Run Lux ray-tracing.

        Parameters
        ----------
        config : RayTraceConfig
            Ray-tracing configuration.
        mpi_ranks : int
            Number of MPI ranks to use.
        verbose : bool
            Print output.

        Returns
        -------
        success : bool
            Whether run completed successfully.
        output : str
            stdout/stderr from run.
        """
        # Generate config file
        config_file = self.work_dir / "lux_config.ini"
        generate_lux_config(config, config_file)
        
        # Build command
        if mpi_ranks > 1:
            cmd = [
                "mpirun", "-np", str(mpi_ranks),
                str(self.lux_executable),
                str(config_file)
            ]
        else:
            cmd = [str(self.lux_executable), str(config_file)]
        
        logger.info(f"Running: {' '.join(cmd)}")
        
        try:
            result = subprocess.run(
                cmd,
                cwd=self.work_dir,
                capture_output=True,
                text=True,
            )
            
            output = result.stdout + result.stderr
            
            if verbose:
                print(output)
            
            success = result.returncode == 0
            
            if not success:
                logger.error(f"Lux failed with return code {result.returncode}")
            
            return success, output
        
        except Exception as e:
            logger.error(f"Failed to run Lux: {e}")
            return False, str(e)
    
    def prepare_particles(
        self,
        coords: np.ndarray,
        masses: np.ndarray,
        output_file: Union[str, Path],
        redshift: float = 0.0,
    ) -> Path:
        """
        Prepare particle data in Lux-compatible format.

        Parameters
        ----------
        coords : ndarray
            Particle coordinates (N, 3) in Mpc/h.
        masses : ndarray
            Particle masses (N,) in Msun/h.
        output_file : str or Path
            Output file path.
        redshift : float
            Snapshot redshift.

        Returns
        -------
        output_path : Path
            Path to created file.
        """
        import h5py
        
        output_file = Path(output_file)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        with h5py.File(output_file, 'w') as f:
            # Store coordinates and masses
            f.create_dataset('Coordinates', data=coords.astype(np.float32))
            f.create_dataset('Masses', data=masses.astype(np.float32))
            
            # Add metadata
            f.attrs['NumParticles'] = len(coords)
            f.attrs['Redshift'] = redshift
        
        logger.info(f"Prepared {len(coords)} particles: {output_file}")
        return output_file


def run_raytrace(
    coords: np.ndarray,
    masses: np.ndarray,
    config: RayTraceConfig,
    lux_executable: Union[str, Path] = "lux",
    work_dir: Optional[Union[str, Path]] = None,
    mpi_ranks: int = 1,
    cleanup: bool = True,
) -> Optional[np.ndarray]:
    """
    Run complete ray-tracing pipeline.

    Parameters
    ----------
    coords : ndarray
        Particle coordinates (N, 3) in Mpc/h.
    masses : ndarray
        Particle masses (N,) in Msun/h.
    config : RayTraceConfig
        Ray-tracing configuration.
    lux_executable : str or Path
        Path to Lux executable.
    work_dir : str or Path, optional
        Working directory.
    mpi_ranks : int
        Number of MPI ranks.
    cleanup : bool
        Remove temporary files after completion.

    Returns
    -------
    kappa : ndarray or None
        Convergence map if successful, None otherwise.

    Examples
    --------
    >>> config = RayTraceConfig(fov=5.0, rt_grid=1024)
    >>> kappa = run_raytrace(coords, masses, config, mpi_ranks=16)
    >>> if kappa is not None:
    ...     print(f"Convergence map shape: {kappa.shape}")
    """
    if work_dir is None:
        work_dir = tempfile.mkdtemp(prefix="lux_")
    else:
        work_dir = Path(work_dir)
        work_dir.mkdir(parents=True, exist_ok=True)
    
    try:
        # Initialize interface
        lux = LuxInterface(lux_executable, work_dir)
        
        # Prepare particle file
        particle_file = work_dir / "particles.h5"
        lux.prepare_particles(coords, masses, particle_file)
        
        # Update config paths
        config.input_path = str(particle_file)
        config.output_path = str(work_dir / "kappa")
        
        # Run ray-tracing
        success, output = lux.run(config, mpi_ranks=mpi_ranks)
        
        if success:
            # Load convergence map
            kappa_file = work_dir / "kappa_z0.fits"
            if kappa_file.exists():
                from astropy.io import fits
                kappa = fits.getdata(kappa_file)
                return kappa
            else:
                # Try HDF5 format
                kappa_file_h5 = work_dir / "kappa_z0.h5"
                if kappa_file_h5.exists():
                    import h5py
                    with h5py.File(kappa_file_h5, 'r') as f:
                        return f['kappa'][:]
        
        logger.error("Ray-tracing failed or output not found")
        return None
    
    finally:
        if cleanup:
            import shutil
            shutil.rmtree(work_dir, ignore_errors=True)


def compute_critical_density(
    redshift_lens: float,
    redshift_source: float,
    omega_m: float = 0.3089,
    h: float = 0.6774,
) -> float:
    """
    Compute critical surface density for lensing.

    Parameters
    ----------
    redshift_lens : float
        Lens redshift.
    redshift_source : float
        Source redshift.
    omega_m : float
        Matter density parameter.
    h : float
        Hubble parameter h = H0 / 100.

    Returns
    -------
    sigma_crit : float
        Critical surface density in Msun/h / (Mpc/h)^2.
    """
    from astropy.cosmology import FlatLambdaCDM
    import astropy.units as u
    import astropy.constants as const
    
    cosmo = FlatLambdaCDM(H0=h*100, Om0=omega_m)
    
    D_l = cosmo.angular_diameter_distance(redshift_lens)
    D_s = cosmo.angular_diameter_distance(redshift_source)
    D_ls = cosmo.angular_diameter_distance_z1z2(redshift_lens, redshift_source)
    
    sigma_crit = (const.c**2 / (4 * np.pi * const.G)) * (D_s / (D_l * D_ls))
    sigma_crit = sigma_crit.to(u.Msun / u.Mpc**2)
    
    # Convert to h units: Msun/h / (Mpc/h)^2 = Msun/Mpc^2 * h
    return sigma_crit.value * h
